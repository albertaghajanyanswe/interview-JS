function foo() {
  const x = 10;
  return {
    x: 20,
    bar: () => {
      // console.log(this);
      console.log(this.x);
    },
    baz: function() {
      // console.log(this)
      console.log(this.x)
    }
  }
}

const o1 = foo();
// console.log(o1);

/*
  *foo() вызывается без контекста (obj.foo()), поэтому this = глобальный объект (window в браузере, global в Node).
  *В строгом режиме — undefined.
  *У стрелок нет собственного this; они «захватывают» то, что было снаружи.
  *Снаружи был this из foo (глобальный объект или undefined). Поэтому при вызове o1.bar() контекст не изменится.
*/
o1.bar(); // undefined

/*
  *Обычная функция получает this во время вызова.
  *Здесь мы зовём её как метод: o1.baz(), значит this = o1.
  *У o1 есть свойство x: 20.
*/
o1.baz(); // 20

/*
  *Вызов foo.call({ x: 30 })
  *Внутри foo this становится { x: 30 }.
  *Стрелочная функция bar лексически «запоминает» именно этот объект.
  *Возвращается o2 = { x: 20, bar, baz } (у него своё поле x: 20).
*/

// const o2 = foo.call({ x: 30 });
// // console.log(o2);

// let y = o2.bar;
// let z = o2.baz;
// console.log('\n')
// y(); // 30
// z(); // undefined

// console.log('\n')

/*
  *o2.bar()
  *bar — стрелка, а стрелки не получают новое this при вызове.
  *Она использует захваченное { x: 30 }.
  *Поэтому выводит объект { x: 30 } и 30.
*/
// o2.bar(); // 30

/*
  *o2.baz()
  *baz — обычная функция‑метод.
  *При вызове obj.method() её this становится самим объектом obj, то есть o2.
  *У o2 свойство x равно 20, поэтому вывод 20.
*/
// o2.baz(); // 20
